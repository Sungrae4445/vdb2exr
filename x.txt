#Convert a 'raw' byte data set into a tiled EXR image by 'slice'

import bpy
import imp
import os
import sys
import struct
import math


def convert_rawbytes_to_exr(fname, oPattern, oframeno, res_x, res_y, res_z,multiRow=False):

    f = open(fname, "rb")

    size = res_x * res_y * res_z
    density = f.read(size)    

    build_exr_from_buffers(gen_filename("mri",oPattern, oframeno), (res_x, res_y, res_z), density, density,density, None, multiRow=multiRow)

    f.close()

# Generate filename by combining name, pattern, frameno
def gen_filename(name, pattern, frameno):
    return pattern % (name, frameno)


def build_exr_from_buffers(filename, dimensions, bufferR, bufferG, bufferB, bufferA, multiRow=False):

    if multiRow:
        numColumns = math.ceil(math.sqrt(dimensions[2]))
        numRows = math.ceil(dimensions[2] / numColumns)
    else:
        numColumns = dimensions[2]
        numRows = 1

    filename = str(dimensions[2])+"_"+str(numColumns)+"x"+str(numRows)+"_"+filename
    print("Building image %s" % filename)

    # Size the image to allow space for Z images of size X by Y
    width = (dimensions[0]+1)*numColumns
    if numRows >1:
        height = (dimensions[1]+1)*numRows
    else:
        height = dimensions[1]

    # Create the image
    image = bpy.data.images.new(filename, width=width, height=height,float_buffer=False, alpha=False, is_data=True)

    # Create an empty array of pixel data (each will hold R, G, B, A values as floats)
    pixels = [None] * width * height
    for x in range(0,width):
        for y in range(0,height):
            pixels[y*width+x] = [0.0,0.0,0.0,0.0]

    print("File '"+filename+"', Dimensions = ("+str(dimensions[0])+","+str(dimensions[1])+","+str(dimensions[2])+")")

    for z in range(0,dimensions[2]):
        print("Processing layer "+str(z))
        #Calculate the location of this 'tile'
        tileNoX = z % numColumns
        tileNoY = int((z - tileNoX) / numColumns)
        tileOffset = tileNoX*(dimensions[0]+1)+tileNoY*width*(dimensions[1]+1)

        #print("Tile = ("+str(tileNoX)+","+str(tileNoY)+") : "+str(tileOffset))

        for x in range(0,dimensions[0]):
            for y in range(0,dimensions[1]):

                p = x+y*dimensions[0]+z*dimensions[0]*dimensions[1]

                # If R, G, or B are 'none' then 0.0 is assumed
                valR = 0
                valG = 0
                valB = 0
                if bufferR != None:
                    #valR = struct.unpack('f',bufferR[p*4:p*4+4])[0]
                    valR = float(bufferR[p])/255

                if bufferG != None:
                    #valG = struct.unpack('f',bufferG[p*4:p*4+4])[0]
                    valG = float(bufferG[p])/255

                if bufferB != None:
                    #valB = struct.unpack('f',bufferB[p*4:p*4+4])[0]
                    valB = float(bufferB[p])/255

                # bufferA can be None to indicate not used (in which case 1.0 is assumed)
                if bufferA != None:
                    valA = float(bufferA[p])/255
                else:
                    valA = 1.0

                #pixels[(y*width)+x+z*(dimensions[0]+1)] = [valR,valG,valB,valA]
                pixels[tileOffset + x + y*width] = [valR,valG,valB,valA]

    print("Image build complete, storing pixels...")

    # 'flatten' the array - so [R1,G1,B1,A1], [R2,G2,B2,A2], [R3,G3,B3,A3],.... becomes R1,B1,G1,A1,R2,G2,B2,A2,R3,G3,B3,A3,....    
    # and store it in the image
    image.pixels = [chan for px in pixels for chan in px]

    print("Updating image...")
    image.update()

    print("Saving image...")
    # Save image to file
    scn = bpy.data.scenes.new('img_settings')
    scn.render.image_settings.file_format = 'OPEN_EXR'
    scn.render.image_settings.exr_codec = 'ZIP'
    scn.render.image_settings.color_mode = 'RGBA'
    #scn.render.image_settings.color_depth = '32'
    img_path = bpy.path.abspath('//')
    img_file = image.name+'.exr'
    image.save_render(img_path+img_file, scene=scn)
    image.use_fake_user = True

    print("Complete.")

convert_rawbytes_to_exr(bpy.path.abspath("//"+"AW_t1_final_norm_361-433-361.raw"), "%s_%06i", 0, 361, 433, 361, multiRow=True)